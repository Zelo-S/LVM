import time
"""
Batch generation for sequnce of images. This script accept a jsonl file
as input. Each line of the jsonl file representing a dictionary. Each line
represents one example in the evaluation set. The dictionary should have two key:

    input: a list of paths to the input images as context to the model.
    output: a string representing the path to the output of generation to be saved.

Ths script runs the mode to generate the output images, and concatenate the
input and output images together and save them to the output path.
"""

import natsort
from datetime import datetime
import gc
import pathlib
import os
import json
from PIL import Image
import numpy as np
import mlxu
from tqdm import tqdm, trange
from multiprocessing import Pool, set_start_method
import einops
import torch
from pathlib import Path

import matplotlib.pyplot as plt

from inference import MultiProcessInferenceModel
from utils import read_image_to_tensor, MultiProcessImageSaver

import inspect2
LOG = True
def log(str_):
    f = inspect2.currentframe()
    i = inspect2.getframeinfo(f.f_back)
    if LOG: print(f"{i.filename}:{i.lineno} --> {i.function} -> {str_}")

FLAGS, _ = mlxu.define_flags_with_default(
    input_file='./input.json', # not used rn
    checkpoint='../LVM_ckpts',
    input_base_dir='',
    output_base_dir='',
    evaluate_mse=False,
    json_input_key='input',
    json_output_key='output',
    json_target_key='target',
    n_new_frames=1,
    n_candidates=5,
    context_frames=16,
    temperature=1.0,
    top_p=1.0,
    n_workers=1,
    dtype='float16',
    torch_devices='',
    batch_size_factor=1,
    max_examples=0,
    resize_output='original',
    include_input=False,
)

# create this according to the json file.
class MultiFrameDataset(torch.utils.data.Dataset):
    def __init__(self, input_files, output_files, target_files=None):
        assert len(input_files)
        self.input_files = input_files
        self.output_files = output_files
        self.target_files = target_files

    def __len__(self):
        return len(self.input_files)

    def __getitem__(self, idx):
        original_size = Image.open(self.input_files[idx][-1]).size
        input_images = np.stack(
            [read_image_to_tensor(f) for f in self.input_files[idx]],
            axis=0
        )

        if self.target_files is not None:
            target_images = np.stack(
                [read_image_to_tensor(f) for f in self.target_files[idx]],
                axis=0
            )
        else:
            target_images = None
        return input_images, target_images, self.output_files[idx], np.array(original_size)


def main(_):

    log(f"Clearning memory: {torch.cuda.empty_cache()} {gc.collect()}")

    assert FLAGS.checkpoint != ''
    set_start_method('spawn')
    print(f'Loading checkpoint from {FLAGS.checkpoint}')
    print(f'Evaluating input file from {FLAGS.input_file}')
    log(f"Dtype: {FLAGS.dtype}")
    # build a model.
    model = MultiProcessInferenceModel(
        checkpoint=FLAGS.checkpoint,
        torch_devices=FLAGS.torch_devices,
        dtype=FLAGS.dtype,
        context_frames=FLAGS.context_frames,
        use_lock=True,
    )

    # input_files: the json file that needs to be generated by the other file.
    input_files = []
    output_files = []

    if FLAGS.evaluate_mse:
        target_files = []
    else:
        target_files = None

    with mlxu.open_file(FLAGS.input_file, 'r') as f:
        for line in f:
            record = json.loads(line)
            input_files.append(record[FLAGS.json_input_key])
            output_files.append(record[FLAGS.json_output_key])
            if FLAGS.evaluate_mse:
                target_files.append(record[FLAGS.json_target_key])

    if FLAGS.max_examples > 0:
        input_files = input_files[:FLAGS.max_examples]
        output_files = output_files[:FLAGS.max_examples]
        if FLAGS.evaluate_mse:
            target_files = target_files[:FLAGS.max_examples]

    if FLAGS.input_base_dir != '':
        input_files = [
            [os.path.join(FLAGS.input_base_dir, x) for x in y]
            for y in input_files
        ]
        if FLAGS.evaluate_mse:
            target_files = [
                [os.path.join(FLAGS.input_base_dir, x) for x in y]
                for y in target_files
            ]

    if FLAGS.output_base_dir != '':
        os.makedirs(FLAGS.output_base_dir, exist_ok=True)
        output_files = [
            os.path.join(FLAGS.output_base_dir, x)
            for x in output_files
        ]
    
    root_dir = "/home/stevex2/data/vision-data/bridge_v2/rigid_objects/im0/"
    directory = pathlib.Path(root_dir)
    input_file_names = [natsort.natsorted([root_dir + f.name for f in directory.iterdir() if f.is_file()])]
    input_files[0] = input_files[0][:-1]
    print(input_file_names)
    dataset = MultiFrameDataset(input_file_names, output_files, target_files)


    input_ims, _, output_im, og_size = dataset.__getitem__(0)
    log(input_ims.shape)
    log(output_im)
    log(og_size)

    data_loader = torch.utils.data.DataLoader(
        dataset,
        # batch_size=FLAGS.batch_size_factor * model.n_processes,
        batch_size=1,
        shuffle=False,
        num_workers=0,
    )
    
    # log("Done with dataloader")

    # batch_images is input.
    
    input_ims = np.expand_dims(input_ims, axis=0)
    log(f"Post expansion input im shape: {input_ims.shape}")

    context_length = input_ims.shape[1]
    log(f"Ctx Length: {context_length}")
    
    
    generated_images = model(
        input_ims,
        FLAGS.n_new_frames,
        FLAGS.n_candidates,
        temperature=FLAGS.temperature,
        top_p=FLAGS.top_p
    )
    
    log(f"\nCuda usage: {torch.cuda.utilization()}\n")
    
    log(f"Generated Images Shape: {len(generated_images)} {generated_images[0][0].shape}")

    for i in range(len(input_ims[0])):
        im = input_ims[0][i]
        plt.subplot(1,len(input_ims[0]), i+1)
        plt.xticks([])
        plt.yticks([])
        plt.title(f"Image {i}")
        plt.imshow(im)

    print(len(generated_images[0]))
    for candidate in generated_images[0]:
        print("Candidate:", np.asarray(candidate).shape)
        im = Image.fromarray((candidate[0] * 255).astype(np.uint8))
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        save_dir = root_dir + "output/"
        os.makedirs(save_dir, exist_ok=True)
        im.save(save_dir + f"output_image_{timestamp}.jpg")
        time.sleep(1.1)
        print("Saving image")

    """
    image_saver = MultiProcessImageSaver(FLAGS.n_workers)

    mses = []

    for batch_images, batch_targets, batch_output_files, batch_sizes in tqdm(data_loader, ncols=0):
        log("Separating data loader")
        # batch_images is input.
        batch_images = batch_images.numpy()

        # 
        context_length = batch_images.shape[1]
        

        generated_images = model(
            batch_images,
            FLAGS.n_new_frames,
            FLAGS.n_candidates,
            temperature=FLAGS.temperature,
            top_p=FLAGS.top_p
        )
        
        
        repeated_batch = einops.repeat(
            batch_images,
            'b s h w c -> b n s h w c',
            n=FLAGS.n_candidates,
        )
        generated_images = np.array(generated_images)

        if FLAGS.evaluate_mse:
            batch_targets = einops.repeat(
                batch_targets.numpy(),
                'b s h w c -> b n s h w c', # batch, candidate, s
                n=FLAGS.n_candidates,
            )
            channels = batch_targets.shape[-1]
            # calculate mse loss.
            mse = np.mean((generated_images - batch_targets) ** 2, axis=(1, 2, 3, 4, 5))

            mses.append(mse * channels)


        if FLAGS.include_input:
            combined = einops.rearrange(
                np.concatenate([repeated_batch, generated_images], axis=2),
                'b n s h w c -> b (n h) (s w) c'
            )
        else:
            combined = einops.rearrange(
                generated_images,
                'b n s h w c -> b (n h) (s w) c'
            )
        combined = (combined * 255).astype(np.uint8)

        n_frames = FLAGS.n_new_frames
        if FLAGS.include_input:
            n_frames += context_length

        if FLAGS.resize_output == '':
            resizes = None

        elif FLAGS.resize_output == 'original':
            resizes = batch_sizes.numpy()
            resizes = resizes * np.array([[n_frames, FLAGS.n_candidates]])
        else:
            resize = tuple(int(x) for x in FLAGS.resize_output.split(','))
            resizes = np.array([resize] * len(batch_sizes))
            resizes = resizes * np.array([[n_frames, FLAGS.n_candidates]])

        image_saver(combined, batch_output_files, resizes)
    if FLAGS.evaluate_mse:
        mses = np.concatenate(mses, axis=0)
        print(f'MSE: {np.mean(mses)}')

    image_saver.close()
    """

if __name__ == "__main__":
    mlxu.run(main)